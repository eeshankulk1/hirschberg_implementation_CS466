from collections import deque

def all_alignments(x, y):

    def F(x, y):
        """A helper function that builds all alignments.

        x, y -- Sequence indices for the original x and y.
        """
        if len(x) == 0 and len(y) == 0:
            yield deque()

        scenarios = []
        if len(x) > 0 and len(y) > 0:
            scenarios.append((x[0], x[1:], y[0], y[1:]))
        if len(x) > 0:
            scenarios.append((x[0], x[1:], None, y))
        if len(y) > 0:
            scenarios.append((None, x, y[0], y[1:]))

        # "xh" and "xt" for "x-head" and "x-tail",
        # "head" being the front of the sequence, and
        # "tail" being the rest of the sequence. 
        # Similarly for "yh" and "yt".
        for xh, xt, yh, yt in scenarios:
            for alignment in F(xt, yt):
                alignment.appendleft((xh, yh))
                yield alignment

    alignments = F(range(len(x)), range(len(y)))
    return map(list, alignments)


def score_alignment(x, y, alignment, match_score=1, mismatch_penalty=-1, gap_penalty=0):
    """
    Compute the score for a given alignment.
    
    x, y -- Original sequences.
    alignment -- The alignment generated by `all_alignments`.
    match_score -- Score for a match.
    mismatch_penalty -- Penalty for a mismatch.
    gap_penalty -- Penalty for a gap.
    """
    score = 0
    for i, j in alignment:
        if i is None or j is None:  # Gap
            score += gap_penalty
        elif x[i] == y[j]:  # Match
            score += match_score
        else:  # Mismatch
            score += mismatch_penalty
    return score


def brute_force_alignment(x, y, match_score=1, mismatch_penalty=-1, gap_penalty=0):
    """
    Find the best alignment between two sequences using brute force.
    
    x, y -- Original sequences.
    match_score -- Score for a match.
    mismatch_penalty -- Penalty for a mismatch.
    gap_penalty -- Penalty for a gap.
    """
    best_score = float("-inf")
    best_alignment = None

    for alignment in all_alignments(x, y):
        score = score_alignment(x, y, alignment, match_score, mismatch_penalty, gap_penalty)
        if score > best_score:
            best_score = score
            best_alignment = alignment

    return best_alignment, best_score


def print_alignment(x, y, alignment):
    """
    Print the alignment in a human-readable format.
    """
    print("".join("-" if i is None else x[i] for i, _ in alignment))
    print("".join("-" if j is None else y[j] for _, j in alignment))


if __name__ == "__main__":
    # Example usage
    x = "CAT"
    y = "CT"

    # Prompt user for scoring parameters
    print("Enter scoring parameters:")
    match_score = int(input("Match score (default 1): ") or 1)
    mismatch_penalty = int(input("Mismatch penalty (default -1): ") or -1)
    gap_penalty = int(input("Gap penalty (default -2): ") or -2)

    # Find the best alignment and its score
    best_alignment, best_score = brute_force_alignment(
        x, y, match_score=match_score, mismatch_penalty=mismatch_penalty, gap_penalty=gap_penalty
    )

    # Print the best alignment and score
    print("\nBest alignment:")
    print_alignment(x, y, best_alignment)
    print(f"Best score: {best_score}")